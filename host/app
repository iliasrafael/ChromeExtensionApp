#!/usr/bin/env python

from __future__ import division

import struct
import sys
import threading
import Queue

import subprocess
import shlex

import argparse
import requests
import urlparse

import zipfile

#from slimit.parser import Parser
from pyjsparser.parser import PyJsParser

import os, shutil
from os import walk

try:
    import Tkinter
    import tkMessageBox
except ImportError:
    Tkinter = None

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
    import os, msvcrt
    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

# Helper function that sends a message to the webapp.
def send_message(message):
    # Write message size.
    sys.stdout.write(struct.pack('I', len(message)))
    # Write the message itself.
    sys.stdout.write(message)
    sys.stdout.flush()

# Thread that reads messages from the webapp.
def read_thread_func(queue):
    message_number = 0
    while 1:
        # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            if queue:
                queue.put(None)
            sys.exit(0)

        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')

        if queue:
            queue.put(text)
        else:
            # In headless mode just send an echo message back.
            send_message('{"echo": %s}' % text)

if Tkinter:
    class NativeMessagingWindow(Tkinter.Frame):
        def __init__(self, queue):
            self.queue = queue

            Tkinter.Frame.__init__(self)
            self.pack()

            self.text = Tkinter.Text(self)
            self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
            self.text.config(state=Tkinter.DISABLED, height=30, width=80)

            self.messageContent = Tkinter.StringVar()

            self.after(100, self.processMessages)

        def processMessages(self):
            while not self.queue.empty():
                self.log("~~~~~~~~~~~~")
                message = self.queue.get_nowait()
                if message == None:
                    self.quit()
                    return
                self.log("Received %s" % message)

                message = message.replace("\"", "")

                #Download and unzip extension files
                self.log("Downloading Source Code... ")
                self.download(message)
                self.log("Download finished successfully.")

                #List all .js files
                f = []
                for (dirpath, dirnames, filenames) in walk('extensions'):
                    for filename in filenames:
                        if filename[-3:] == '.js':
                            path = dirpath+"/"+filename
                            f.append(path)

                tkMessageBox.showinfo('Files:', f)


                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                #Parsing
                #parser = Parser()
                try:
                    parser = PyJsParser()
                    for jsfile in f:
                        self.log("Parsing file "+jsfile+" ...")
                        with open(jsfile, 'r') as readfile:
                            data = readfile.read().decode('utf-8')
                        tree = parser.parse(data)

                        self.log("File "+jsfile+" parsed successfully.")
                        #result = tree.to_ecma()
                        tkMessageBox.showinfo(jsfile, tree)


                except Exception, e:
                    tkMessageBox.showinfo('Application',  e)

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                #Delete extension files
                for the_file in os.listdir('extensions'):
                    file_path = os.path.join('extensions', the_file)
                    try:
                        if os.path.isfile(file_path):
                            os.unlink(file_path)
                        elif os.path.isdir(file_path): shutil.rmtree(file_path)
                    except Exception as e:
                        tkMessageBox.showinfo('Application',  e)

            self.after(100, self.processMessages)

        def send(self):
            text = "AAAAA"
            self.log('Sending %s' % text)
            try:
                send_message(text)
            except Exception, e:
                tkMessageBox.showinfo('Application',  e)

            #sys.exit(1)

        def log(self, message):
            self.text.config(state=Tkinter.NORMAL)
            self.text.insert(Tkinter.END, message + "\n")
            self.text.config(state=Tkinter.DISABLED)

        def download(self, message):
            try:
                CRX_URL = "https://clients2.google.com/service/update2/crx?" \
                "response=redirect&prodversion=62.0&x=id%3D~~~~%26installsource%3Dondemand%26uc"
                USER_AGENT = "Chrome/62.0.3202.94"
                headers = {
                    "User-Agent": USER_AGENT,
                    "Referer": "https://chrome.google.com",
                }

                chrome_app_id = message.split("/")[-1]
                file_name = message.split("/")[-2]

                download_url = CRX_URL.replace("~~~~", chrome_app_id)

                r = requests.get(url=download_url, headers=headers, stream=True, verify=False)

                redirects = r.history
                if len(redirects) > 0:
                    redirect_header = redirects[-1].headers
                    if "location" in redirect_header:
                        loc = redirect_header["location"]
                        uparse = urlparse.urlparse(loc)
                        splits = uparse.path.split("/")
                        _fname_ = splits[-1]

                if _fname_:
                    file_name = _fname_.replace("extension", file_name)
                else:
                    file_name += ".crx"

                chunk_size = 16 * 1024
                dowloaded_bytes = 0
                with open(file_name, 'wb') as fd:
                    for chunk in r.iter_content(chunk_size):
                        fd.write(chunk)

                #Unzip 
                fantasy_zip = zipfile.ZipFile(file_name)
                fantasy_zip.extractall('extensions')
                fantasy_zip.close()

            except Exception, e:
                tkMessageBox.showinfo('Application', e)


def Main():
    if not Tkinter:
        send_message('"Tkinter python module wasn\'t found. Running in headless ' +
                     'mode. Please consider installing Tkinter."')
        read_thread_func(None)
        sys.exit(0)

    queue = Queue.Queue()

    main_window = NativeMessagingWindow(queue)
    main_window.master.title('Application')

    thread = threading.Thread(target=read_thread_func, args=(queue,))
    thread.daemon = True
    thread.start()

    main_window.mainloop()

    sys.exit(0)

if __name__ == '__main__':
    Main()
