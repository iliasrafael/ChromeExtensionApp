#!/usr/bin/env python

from __future__ import division

import struct
import sys
import threading
import Queue

import subprocess
import shlex

import argparse
import requests
import urlparse

try:
    import Tkinter
    import tkMessageBox
except ImportError:
    Tkinter = None

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
    import os, msvcrt
    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

# Helper function that sends a message to the webapp.
def send_message(message):
    # Write message size.
    sys.stdout.write(struct.pack('I', len(message)))
    # Write the message itself.
    sys.stdout.write(message)
    sys.stdout.flush()

# Thread that reads messages from the webapp.
def read_thread_func(queue):
    message_number = 0
    while 1:
        # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            if queue:
                queue.put(None)
            sys.exit(0)

        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')

        if queue:
            queue.put(text)
        else:
            # In headless mode just send an echo message back.
            send_message('{"echo": %s}' % text)

if Tkinter:
    class NativeMessagingWindow(Tkinter.Frame):
        def __init__(self, queue):
            self.queue = queue

            Tkinter.Frame.__init__(self)
            self.pack()

            self.text = Tkinter.Text(self)
            self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
            self.text.config(state=Tkinter.DISABLED, height=10, width=40)

            self.messageContent = Tkinter.StringVar()
            #self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
            #self.sendEntry.grid(row=1, column=0, padx=10, pady=10)

            #self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
            #self.sendButton.grid(row=1, column=1, padx=10, pady=10)

            self.after(100, self.processMessages)

        def processMessages(self):
            while not self.queue.empty():
                self.log("~~~~~~~~~~~~")
                message = self.queue.get_nowait()
                if message == None:
                    self.quit()
                    return
                self.log("Received %s" % message)

                message = message.replace("\"", "")

                self.log("Downloading Source Code... ")
                self.download(message)
                self.log("Download finished successfully.")

                self.send()

                #self.after(100, self.Send)
                #send_message("AAAAAAAAAAA")
                #text = "OLA POPA NOT!!!"
                #self.log('Sending %s' % text)
                #try:
                #  send_message(text)
                #except IOError:
                #  tkMessageBox.showinfo('Native Messaging Example',
                #       'Failed to send message.')
                #sys.exit(1)
                #time.sleep(0.01)

            self.after(100, self.processMessages)

        def send(self):
            #text = "AAAAA".encode('utf-8')
            text = "AAAAA"
            self.log('Sending %s' % text)
            try:
                send_message(text)
            except Exception, e:
                tkMessageBox.showinfo('Native Messaging Example',  e)

            #sys.exit(1)

        def log(self, message):
            self.text.config(state=Tkinter.NORMAL)
            self.text.insert(Tkinter.END, message + "\n")
            self.text.config(state=Tkinter.DISABLED)

        def download(self, message):
            try:
                CRX_URL = "https://clients2.google.com/service/update2/crx?" \
                "response=redirect&prodversion=62.0&x=id%3D~~~~%26installsource%3Dondemand%26uc"
                USER_AGENT = "Chrome/62.0.3202.94"
                headers = {
                    "User-Agent": USER_AGENT,
                    "Referer": "https://chrome.google.com",
                }

                chrome_app_id = message.split("/")[-1]
                file_name = message.split("/")[-2]

                download_url = CRX_URL.replace("~~~~", chrome_app_id)

                r = requests.get(url=download_url, headers=headers, stream=True, verify=False)

                redirects = r.history
                if len(redirects) > 0:
                    redirect_header = redirects[-1].headers
                    if "location" in redirect_header:
                        loc = redirect_header["location"]
                        uparse = urlparse.urlparse(loc)
                        splits = uparse.path.split("/")
                        _fname_ = splits[-1]

                if _fname_:
                    file_name = _fname_.replace("extension", file_name)
                else:
                    file_name += ".crx"

                chunk_size = 16 * 1024
                dowloaded_bytes = 0
                with open(file_name, 'wb') as fd:
                    for chunk in r.iter_content(chunk_size):
                        fd.write(chunk)
                        #dowloaded_bytes += len(chunk)
                        #sys.stdout.write("\r" + self.byte_to_human(dowloaded_bytes))
                        #sys.stdout.flush()

            except Exception, e:
                tkMessageBox.showinfo('Native Messaging Example', e)

        def byte_to_human(self, len_in_byte):
            """
            Converts byte into human readable format.
            :param len_in_byte:
            :return:
            """
            in_kb = len_in_byte / 1024
            in_mb = in_kb / 1024
            in_gb = in_mb / 1024

            if in_kb < 1024:
                return "%.2f KB" % in_kb

            if in_mb < 1024:
                return "%.2f MB" % in_mb

            if in_gb > 1:
                return "%.2f GB" % in_gb

def Main():
    if not Tkinter:
        send_message('"Tkinter python module wasn\'t found. Running in headless ' +
                     'mode. Please consider installing Tkinter."')
        read_thread_func(None)
        sys.exit(0)

    queue = Queue.Queue()

    main_window = NativeMessagingWindow(queue)
    main_window.master.title('Native Messaging Example')

    thread = threading.Thread(target=read_thread_func, args=(queue,))
    thread.daemon = True
    thread.start()

    main_window.mainloop()

    sys.exit(0)

if __name__ == '__main__':
    Main()
